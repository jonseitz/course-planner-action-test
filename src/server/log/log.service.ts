import {
  Injectable,
  Inject,
  Logger as NestLogger,
  Global,
} from '@nestjs/common';
import { Logger as TypeORMLogger } from 'typeorm';
import winston, { Logger as WinstonLogger } from 'winston';
import { ConfigService } from 'server/config/config.service';
import { StreamOptions } from 'morgan';
import { TYPEORM_LOG_LEVEL, LOG_LEVEL } from 'common/constants';
import util from 'util';

/**
 * Represents a value that can be directly written to the logs, without needing
 * to go through util.inspect
 */
type Writable = string | number;

/**
 *  Represents more complex objects that should be passed through util.inspect
 *  before they can be meaningfully written to the console.
 */
export type Inspectable = Record<string, unknown>
| Record<string, unknown>[]
| Writable[]
| unknown[];

/**
 * A general type for any data that can be logged by the logger
 */

export type Loggable<T> = T extends Writable
  ? Writable
  : T extends Record<Writable, unknown>
    ? Inspectable
    : unknown;

/**
 */
}

/**
 * An injectable service that instantiates a Winston logger, and overwrites the
 * existing Nest logging methods with Winston's methods.
 *
*/

@Global()
@Injectable()
class LogService extends NestLogger implements TypeORMLogger {
  /**
   * The winston instance that will be used inside the service
   */
  private readonly logger: WinstonLogger;

  /**
   * The config service
   */
  private readonly config: ConfigService;

  public constructor(
  @Inject(ConfigService) config: ConfigService
  ) {
    super();
    this.config = config;
    this.logger = winston.createLogger({
      level: config.logLevel,
      format: winston.format.combine(
        winston.format.timestamp(),
        // Define a custom log format
        winston.format.printf((info) => {
          const fmtLevel = `[${info.level.toUpperCase()}]`.padStart(10);
          return `${info.timestamp as string} ${fmtLevel}  ${
            info.label ? `(${info.label as string}) ` : ''
          }${info.message}`;
        })
      ),
      transports: [
        new winston.transports.Console(),
      ],
    });
  }

  /**
   * Helper function that wraps util.inspect and passes in our defined options
   */
  private inspect<T>(obj: Loggable<T>): string {
    return util.inspect(obj, {
      depth: Infinity,
      colors: this.config.isDevelopment,
      compact: false,
    });
  }

  /**
   * Log errors thrown in the application.
   * Accepts an optional "trace" argument for compatibility with Nest's
   * built-in logger.
   * Will also accept an Error as its only argument.
   * LOG LEVEL: 0
   */
  public error<T>(
    message: T extends Error ? Error : Writable,
    trace?: T extends Error ? never : string,
    label?: Writable
  ): void {
    if (message instanceof Error) {
      this.logger.error(message.message, { label });
      this.logger.error(message.stack, { label });
    } else {
      this.logger.error(message.toString(), { label });
      if (trace) {
        this.logger.error(trace, { label });
      }
    }
  }

  /**
   * Handles logging query errors generated by TypeORM by passing them to our
   * error function
   */
  public logQueryError(
    error: Writable,
    query: Writable,
    parameters?: Inspectable
  ): void {
    this.error(error, null, 'TypeORM');
    this.error(query, null, 'TypeORM');
    if (Array.isArray(parameters) && parameters.length > 0) {
      this.error(this.inspect(parameters), null, 'TypeORM');
    }
  }

  /**
   * Record issues that don't degrade the application, but may produce
   * less-desirable results.
   * LOG LEVEL: 1
   */
  public warn(message: Writable, label?: string):void {
    this.logger.warn(message.toString(), { label });
  }

  /**
   * Method used by TypeORM to flag long-running queries that could indicate
   * performance issues.
   * The threshold for slow queries is set by the `maxQueryExecutionTime`
   * in the connection options in app.module.ts
   * Messages will be passed to our warn function
   */

  public logQuerySlow(time: number, query: Writable): void {
    this.warn(`The following query took ${time}ms to run`, 'TypeORM');
    this.warn(query, 'TypeORM');
  }

  /**
   * The standard log level, used to for relaying regular information about the
   * status of the app, e.g. Nest startup messages
   * LOG LEVEL: 2
   */
  public info(message: Writable, label?: string):void {
    this.logger.info(message.toString(), { label });
  }

  /**
   * The base logging function used by Nest and TypeORM. They use different
   * formats, so if the first arugment is one of TypeORM's log levels it will
   * expect the log message to be the second argument. Otherwise, the first
   * argument will be treated as the log message.
   * In our implementaiton, log/info messages will go to the info stream, and
   * warnings will go to the warn stream
   */
  public log<T>(
    messageOrLevel: T extends TYPEORM_LOG_LEVEL ? TYPEORM_LOG_LEVEL : Writable,
    message?: T extends TYPEORM_LOG_LEVEL ? Writable : never
  ): void {
    if (messageOrLevel === TYPEORM_LOG_LEVEL.LOG
        || messageOrLevel === TYPEORM_LOG_LEVEL.INFO) {
      this.info(message.toString(), 'TypeORM');
    } else if (messageOrLevel === TYPEORM_LOG_LEVEL.WARN) {
      this.warn(message.toString(), 'TypeORM');
    } else {
      this.info(messageOrLevel.toString(), 'NestJS');
    }
  }

  /**
   * Records all requests/responses handled by the application, similar to
   * Apache/nginx logs
   * LOG LEVEL: 3
   */
  public http(message: Writable, label?: string):void {
    this.logger.http(message.toString(), { label });
  }

  /**
   * Exposes a writable stream for http messages that can be used by morgan for
   * generating apache-style logs.
   */
  public get httpStream(): StreamOptions {
    return {
      write: (message: string): void => {
        this.http(message, 'Express');
      },
    };
  }

  /**
   * Records more detailed information about the running application. Includes:
   *  - ID of user's associated with requests
   *  - Notifications about data read from and written to the database
   *
   *  This method will expand objects/arrays passed as arguments, such as:
   *  - Body content of POST/PUT requests
   *  - Body content returned in responses
   * LOG LEVEL: 4
   */
  public verbose<T>(message: Loggable<T>, label?: string): void {
    if (typeof message === 'string') {
      this.logger.verbose(message, { label });
    } else if (typeof message === 'number') {
      this.logger.verbose(message.toString(), { label });
    } else {
      this.logger.verbose(this.inspect(message), { label });
    }
  }

  /**
   * Provides more granual data about the execution flow of the app. Only intended for use in development
   * Like [[verbose]], this method will expand objects/arrays
   * LOG LEVEL: 5
   */
  public debug<T>(message: Loggable<T>, label?: string):void {
    if (typeof message === 'string') {
      this.logger.debug(message, { label });
    } else if (typeof message === 'number') {
      this.logger.debug(message.toString(), { label });
    } else {
      this.logger.debug(this.inspect(message), { label });
    }
  }

  /**
   * Logs every query run by TypeORM, with parameters
   * Will write a notification to the verbose stream
   * Will write the query and parameters to the debug stream
   */
  public logQuery(query: Writable, parameters?: Inspectable): void {
    this.verbose('Running query against database', 'TypeORM');
    this.debug(query, 'TypeORM');
    if (Array.isArray(parameters) && parameters.length > 0) {
      this.debug(this.inspect(parameters), 'TypeORM');
    }
  }

  /**
   * Logs messages from the TypeORM migration process.
   * Will write a notification to our verbose stream
   * Will log the full migration message to our debug stream
   */
  public logMigration(message: Writable): void {
    this.verbose('Running migration process', 'TypeORM');
    this.debug(message, 'TypeORM');
  }

  /**
   * Logs messages from the TypeORM schema building process.
   * Will write a notification to our verbose stream
   * Will log the full schema build message to our debug stream
   */
  public logSchemaBuild(message: Writable): void {
    this.verbose('Running Schema build process', 'TypeORM');
    this.debug(message, 'TypeORM');
  }
}

export { LogService };
